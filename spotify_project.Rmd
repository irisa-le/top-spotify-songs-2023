---
title: "Top Spotify Songs of 2023"
author: "Irisa Le"
date: "2025-07-19"
output: html_document
---

## Load libraries
```{r}
library(ggplot2)
library(dplyr)
library(corrplot)
library(GGally) # correlation heat matrix
library(patchwork) # organize visualization output
library(car) # inverse response plot
library(MASS) # box-cox transformation
```

## Load data
```{r}
songs <- read.csv("spotify-2023.csv", encoding = "UTF-8")
```

```{r}
dim(songs)
```

```{r}
View(songs)
```

```{r}
# clean data with ._ and artist.s.name -> artist name
colnames(songs)
```

### Data cleaning
#### Rename unclear columns
```{r}
songs <- rename(songs, artist_name = artist.s._name,
                danceability_pct = danceability_., valence_pct = valence_., energy_pct = energy_.,          
                acousticness_pct = acousticness_., instrumentalness_pct = instrumentalness_., 
                liveness_pct = liveness_., speechiness_pct = speechiness_.)
```

#### Drop columns with platform-specific data excluding Spotify
```{r}
songs <- songs %>%
  select(-in_apple_charts, -in_deezer_charts, -in_shazam_charts,
         -in_apple_playlists, -in_deezer_playlists)
```

#### Look at existing columns
```{r}
colnames(songs)
```

```{r}
# Top 6 rows
head(songs)
```

```{r}
# Last 6 rows
tail(songs)
```

```{r}
# clean data: make streams of integer class,
summary(songs)
```

#### Check for missing values (NA) or empty character strings
```{r}
# check if any numeric column have NA values
colSums(is.na(songs))
```

```{r}
# check for blank character values ""
# 'key'
sapply(songs, function(col) any(col == "", na.rm = TRUE))
```

```{r}
# set "" to NA
# check how many NAs there are now
songs[songs == ""] <- NA
colSums(is.na(songs))
```

```{r}
# convert 'streams' column to be of numeric class, and keep NAs
songs <- songs %>%
  mutate(streams = as.numeric(streams))
```

#### Check which rows introduced NA values
```{r}
which(is.na(songs$streams))
```

#### Drop row 575 and row 124
```{r}
songs <- songs %>%
  slice(-c(124, 575))
```

```{r}
dim(songs)
```

#### Export data for manual cleaning (encoding, missing key values)
```{r}
write.csv(songs, "spotify-2023-partially-cleaned.csv", row.names = FALSE)
```

### Import cleaned data
```{r}
songs_clean <- read.csv("spotify-2023-finalclean.csv", encoding="UTF-8")
head(songs_clean)
```

```{r}
unique(songs_clean$in_spotify_charts)
```

#### Compare dimensions of original and clean datasets
```{r}
dim(songs)
dim(songs_clean)
```

#### Compare NAs
```{r}
colSums(is.na(songs_clean))
```

### Exploratory Data Analysis
#### Pair plot
```{r}
songs_clean_subset <- songs_clean[, c("streams", "artist_count", "bpm", "danceability_pct", "energy_pct", "valence_pct", "acousticness_pct", "instrumentalness_pct", "liveness_pct", "speechiness_pct")]

# each box in upper half diagonal of grid displays the scatter plot
# between two variables, which shows the dispersion of data
# each box in lower half diagonal gives scatter plot with a line of the
# best fit between two variables which shows the dispersion of data around the line
pairs(songs_clean_subset, pch=1, col = 'gray', lower.panel=panel.smooth)
```

#### Correlation matrix
```{r}
corrplot(cor(songs_clean_subset))
```

#### Barplots for songs released by year and month
```{r}
# Barplot: Song Releases by Month
month_names <- c("January", "February", "March", "April", "May", "June", "July", 
                 "August", "September", "October", "November", "December")

songs_per_month <- ggplot(songs_clean, aes(x=factor(released_month))) +
                    geom_bar(fill="darkgreen") +
                    scale_x_discrete(labels = month_names) +
                    labs(x="Month of Release", y="Count", title="Song Releases by Month")  +
                    coord_flip() +
                    theme_minimal()
                    


# Barplot: Song Releases by Year
year_range <- min(songs_clean$released_year):2023

songs_per_year <- ggplot(songs_clean, aes(x=released_year)) +
                    geom_bar(fill="darkgreen") +
                    scale_x_discrete(labels = year_range) +
                    labs(x="Years of Release (1930-2023)", y="Count", title="Song Releases by Year") +
                    coord_flip()+
                    theme_minimal()

songs_per_year | songs_per_month
```

#### Barplot: Top 10 Artists by Number of Songs
Shows only the top N artists based on the number of songs they have
```{r}
# Barplot: Top 10 Artists by Number of Songs
top_artists_numsongs <- songs_clean %>%
  count(artist_name) %>%
  top_n(10, n)  

top10_numsongs <- ggplot(top_artists_numsongs, aes(x = reorder(artist_name, n), y = n)) +
  geom_bar(stat="identity", fill="darkgreen") +
  labs(x = "Artist", y = "Number of Songs", title = "Top 10 Artists by Number of Top Songs") +
  coord_flip() +  
  theme_minimal()

# Barplot: Top 10 Artists by Number of Streams
## Get the total streams per artist and select the top 10
top_artists_streams <- songs_clean %>%
  group_by(artist_name) %>%
  summarise(total_streams = sum(streams)) %>%  # Sum streams for each artist
  top_n(10, total_streams)  # Keep the top 10 artists by total streams

## Create the bar plot
top10_numstreams <- ggplot(top_artists_streams, aes(x = reorder(artist_name, total_streams), y = total_streams, fill = artist_name)) +
  geom_bar(stat = "identity", fill="darkgreen") +
  labs(x="Artist", y = "Total Streams", title = "Top 10 Artists by Total Streams") +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none")

top10_numsongs | top10_numstreams
```

#### Scatterplot
```{r}
# Fits a linear model and displays confidence interval
scatterplot1 <- ggplot(songs_clean, aes(x=acousticness_pct, y=energy_pct)) +
  geom_point() +
  geom_smooth(method=lm) +
  labs(x="Acousticness Percentage", y="Energy Percentage") +
  theme_minimal()

scatterplot2 <- ggplot(songs_clean, aes(x=valence_pct, y=danceability_pct)) +
  geom_point() +
  geom_smooth(method=lm) +
  labs(x="Valence Percentage", y="Danceability Percentage") +
  theme_minimal()

scatterplot3 <- ggplot(songs_clean, aes(x=energy_pct, y=acousticness_pct)) +
  geom_point() +
  geom_smooth(method=lm) +
  labs(x="Energy Percentage", y="Acousticness Percentage") +
  theme_minimal()

scatterplot4 <- ggplot(songs_clean, aes(x=danceability_pct, y=valence_pct)) +
  geom_point() +
  geom_smooth(method=lm) +
  labs(x="Danceability Percentage", y="Valence Percentage") +
  theme_minimal()

(scatterplot1 | scatterplot2) / 
(scatterplot3 | scatterplot4)
```


```{r}
ggplot(songs_clean, aes(x=artist_count, y=streams)) +
  geom_point() +
  labs(x = "Artist Count", y = "Total Streams", title = "Streams by Artist Count") +
  theme_minimal()
```

```{r}
colnames(songs_clean)
```
## Modeling
### Explore original distribution of y (streams)
```{r}
y <- songs_clean$streams
par(mfrow=c(1,3))
plot(density(y, bw="SJ", kern="gaussian"), type="l",
main="Gaussian kernel density estimate", xlab="streams")
boxplot(y, ylab="streams")
qqnorm(y, ylab="streams")
```

### Model 1: Multiple Linear Regression with Main Effects Only
```{r}
lm1 <- lm(streams ~ bpm + key + mode + danceability_pct + valence_pct + energy_pct + acousticness_pct + instrumentalness_pct + liveness_pct + speechiness_pct, data=songs_clean)
summary(lm1)
```

```{r}
par(mfrow=c(2,2))
plot(lm1)
```

### Consider transformation of response:
#### Inverse Response Plot
```{r}
par(mfrow=c(1,1))
inverseResponsePlot(lm1, key=TRUE)
```

#### Power Transformation of y
```{r}
bc <- powerTransform(y ~ 1)
summary(bc)
```

### Model 2: log(response) only
```{r}
lm2 <- lm(log(streams) ~ bpm + key + mode + danceability_pct + valence_pct + energy_pct + acousticness_pct + instrumentalness_pct + liveness_pct + speechiness_pct, data=songs_clean)
summary(lm2)
```

#### Diagnostic plots 
```{r}
par(mfrow=c(2,2))
plot(lm2)
```
#### Cook's distance and outliers
```{r}
cooksD <- cooks.distance(lm2)
cooksD
```

### Model 3: log(response) and transformed predictors
```{r}
# Box-cox transformation
sapply(songs_clean[, c("streams", "bpm", "danceability_pct", "valence_pct", "energy_pct", 
                       "acousticness_pct", "instrumentalness_pct", 
                       "liveness_pct", "speechiness_pct")], 
       function(x) sum(x <= 0))

predictors_subset <- songs_clean[, c("bpm", "danceability_pct", "valence_pct", "energy_pct", 
                                     "acousticness_pct", "instrumentalness_pct", 
                                     "liveness_pct", "speechiness_pct")]

predictors_subset$acousticness_pct <- predictors_subset$acousticness_pct + 1e-6
predictors_subset$instrumentalness_pct <- predictors_subset$instrumentalness_pct + 1e-6

sapply(predictors_subset[, c("bpm", "danceability_pct", "valence_pct", "energy_pct", 
                       "acousticness_pct", "instrumentalness_pct", 
                       "liveness_pct", "speechiness_pct")], 
       function(x) sum(x <= 0))

songs_transformed <- songs_clean %>%
  mutate(
    bpm_bc = bpm^0.2465,
    danceability_bc = danceability_pct^1.6307,
    valence_bc = valence_pct^0.8023,
    energy_bc = energy_pct^1.3468,
    acousticness_bc = acousticness_pct^0.3204,
    instrumentalness_bc = 1 / (instrumentalness_pct^0.6938),
    liveness_bc = 1 / (liveness_pct^0.3416),
    speechiness_bc = 1 / (speechiness_pct^0.6286)
  )
```

```{r}
lm3 <- lm(
  log(streams) ~ 
    (bpm^0.2465) + 
    key + 
    mode + 
    (danceability_pct^1.6307) + 
    (valence_pct^0.8023) + 
    (energy_pct^1.3468) + 
    (acousticness_pct^0.3204) + 
    (1 / (instrumentalness_pct^0.6938)) + 
    (1 / (liveness_pct^0.3416)) + 
    (1 / (speechiness_pct^0.6286)),
  data = songs_clean
)
```

```{r}
lm3 <- lm(log(streams) ~ bpm^0.2465 + key + mode + danceability_pct^1.6307 + valence_pct^0.8023 + energy_pct^1.3468 + acousticness_pct^0.3204 + 1/(instrumentalness_pct^0.6938) + 1/(liveness_pct^0.3416) + 1/(speechiness_pct^0.6386), data=predictors_subset)
summary(lm3)
```

#### Look at outliers
```{r}
songs_clean[c(56, 179, 618, 700:710),]
```

```{r}
cooksdist <- 4/(951)
cooksdist
```

### Model 2: Multiple Linear Regression with Select Interactions
```{r}
lm2 <- lm(log(streams) ~ bpm + key + mode + (acousticness_pct * energy_pct) + (valence_pct * danceability_pct) + (speechiness_pct:danceability_pct) + (valence_pct:energy_pct) + (bpm:energy_pct) + instrumentalness_pct + liveness_pct + speechiness_pct, data=songs_clean)
summary(lm2)
```



















